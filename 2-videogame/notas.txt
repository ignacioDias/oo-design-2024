El evitar el uso de switches llevó a la creación de muchas clases que,
a mi parecer, fueron totalmente innecesarias y terminan complicando más el mantenimiento
del código ante nuevos requerimientos..

Por ejemplo, en ConsoleDisplay pasamos de

public void display() {
    print(currentEvent.toString());
}

...a necesitar una función en cada caso, ante un nuevo requerimiento tendría que modificar
las funciones de cada caso en cada Display:

public void display(String output) {
    print(output);
}

donde cada observer (a su vez display) ahora tiene que llamar a display de la siguiente manera:

void updateAttack() {
    display(...)
}
void updateWinner(Character winer){...}
...

Antes, en un logger genérico que solo muestra una salida (en este caso en pantalla)
sería así el update (única función, no una por cada evento):

void update() {
    display(); //función definida al principio
}

Si yo elijo tener un switch centralizado en FightEvent, puedo "sufrir" las modificaciones
en una sola clase y limitarme a eso, en caso de que necesite una salida diferente,
(como pasa con las estadísticas) puedo optar con no usar la salida genérica y simplemente
manejarme con los atributos de la clase FightEvent.. obvio, surge otro switch para ver en
qué caso del ENUM de eventos nos encontramos, pero la cantidad de código es mucho menor y,
a mi parecer, sigue siendo mucho más legible y fácil de mantener, ya que solo modifico 1
switch cada tantas clases, en lugar de borrar/agregar una función por cada observer
(suponiendo que quiero borrar/agregar un evento, respectivamente.) en cada implementación
de éste..

No me estoy pegando a Clean Code, pero considero que el resultado es mejor para el
programador (tanto el que lo escribe, como el que lo mantiene)

-----------------

Un defecto que sí comparto es que la clase FightEvent termina con atributos que no
necesariamente necesita, un caso de Winner va a tener innecesariamente los atributos de
attacker, defender y damage..

Así que ahora FightEvent va a quedar como una interfaz y cada clase va a tener lo suyo,
pero no voy a evitar hacer un notify por cada clase, no le veo sentido. Cada clase va
a tener su propio toString y va a seguir la lógica de antes, solo que FightEvent pasa
a ser una interfaz

Entonces mantengo un switch en clases de display

En resumen, comúnmente evitamos switches para no tener que modificar uno por uno, pero
en este caso el hacer eso nos lleva a tener que definir un método por cada caso del switch
multiplicado por la cantidad de observers

Otra idea es hacer a observer una clase abstracta, pero vamos a tener que usar Override
a cada rato